<div dir="rtl">

تسک را [اینجا](TASK.md) مشاهده کنید.

</div>
  
<div dir="rtl">

طبق نیازمندی های مسئله 2 مورد به صورت ویژه مورد توجه قرار گرفته است:

1- کارایی و مقیاس پذیری با در نظر گرفتن تعداد بالای امتیاز برای یک مطلب و تعداد بالای درخواستهای ورودی به برنامه


در ادامه راه‌حل‌های متداول برای بهبود کارایی و مقیاس پذیری اپلیکیشن را به اختصار مورد بررسی قرار می دهیم.


</div>


<div dir="rtl">


> بهینه سازی دیتابیس (Database Optimization)

- ایجاد ایندکس روی فیلدهای مورد نظر

- افزودن فیلدهایی مانند average_rating و ratings_count در مدلArticle و به روزرسانی فیلدهای مورد شاره با ثبت یا به روزر رسانی امتیاز روی یک مطلب به جای محاسبه میانگین امتیازات و تعداد کاربران در هر درخواست (به صورت لحظه ای)

موارد مورد اشاره از تعادل مناسبی بین فاکتورهایی نظیر پیچیدگی اضافه شده به برنامه و افزایش کارایی برخوردار است، هرچند در خصوص مورد دوم باید به امکان بروز ناسازگاری دادگان در صورت عدم به روزرسانی صحیح فیلدهای اضافه شده اشاره کرد.



> استفاده از cache

- کش کردن نتایج برای endpointهایی نظیر لیست مقالات (کاهش سربار بازیابی نتایج از دیتابیس  به ازای هر درخواست)

 نکته ی حائز توجه این که تنظیم مدت زمان valid بودن کش و پیاده سازی مکانیزم مناسب برای invalid کردن کش باید مورد توجه قرار گیرد .


>محاسبات آسنکرون

- قرار دادن امتیازات جدید در یک صف و پردازش آنها به صورت دسته ای 

کاهش فشار لحظه ای و مقیاس پذیری بالا از مزایای این روش است. هرچند باید به تاخیر در به روزرسانی امتیازات و پیچیدگی پیاده سازی نیز اشاره کرد.



>استفاده از دیتابیس های توزیع شده

- توزیع دادگان در پارتیشن های مختلف روی چند دیتابیس (shards) یا استفاده از read replicas 

باید در نظر داشت که این مورد در مقیاسهای بسیار بزرگ کاربرد داشته و پیچیدگی پیاده سازی و نگهداری به مراتب بیشتری نسبت به راهکارهای قبلی دارد.


از مجموع راهکارهای مورد اشاره و با در نظر گرفتن پیچیدگی پیاده سازی،  موارد مرتبط با بهینه سازی دیتابیس و کش کردن نتایج مورد استفاده قرار گرفته است.

</div>

---

<div dir="rtl">

2- ارائه ی روشی برای جلوگیری از بایاس شدن امتیاز یک مطلب در صورت وقوع حملات هماهنگ نظیر امتیازدهی هیجانی و غیرواقعی تعداد زیادی از کاربران به آن مطلب.

در ادامه مرور مختصری بر سه نمونه از راه حل های جلوگیری از امتیازدهی هیجانی خواهیم داشت.

</div>

<div dir="rtl">

>  محدود کردن امکان ثبت امتیاز از یک IP آدرس (IP Rate Limiting) 

در این روش از هر آدرس IP تعداد معینی امتیاز در یک بازه ی زمانی قابل ثبت است. به این ترتیب از ثبت امتیازات متعدد توسط یک فرد یا گروه در یک بازه ی زمانی مشخص جلوگیری می‌شود.
سادگی در پیاده سازی از مزایا و جلوگیری از ثبت امتیاز توسط کاربرانی که از یک آدرس مشترک استفاده می کنند (شبکه ی های دانشگاهی) ازمعایب این روش است.


> امتیازدهی بر اساس اعتبار کاربران (Trust Score)

در این روش  براساس رفتار کاربر در سیستم یک نمره ی اعتباری به وی اختصاص داده می‌شود. کاربرانی که سابقه فعالیت مثبت دارند و مدت طولانی ‌تری از سیستم استفاده کرده‌اند، نمره ی بالاتری دارند و امتیازات آن‌ها به یک مقاله تاثیر بیشتری روی میانگین نهایی دارد.

با استفاده از این روش می توان وزن امتیازات نادرست توسط کاربران تازه وارد یا مشکوک را کاهش داد. هرچند باید پیچیدگی و زیرساخت لازم برای محاسبه و به روزرسانی این نمره را مد نظر قرار داد. همچنین این روش برای کاربران جدید نیز به نوعی ناعادلانه محسوب می شود.


> محاسبه ی میانگین امتیازات بر اساس زمان ثبت امتیاز (Time-Weighted Averages)

در این روش برای محاسبه ی میانگین امتیازات یک مقاله، امتیازات قدیمی وزن کمتری نسبت به امتیازات جدیدتر می گیرند. با این که امتیازات جدیدتر وزن بیشتری خواهند داشت اما با گذر زمان وزن آنها نیز کاهش پیدا خواهد کرد. به این ترتیب، تغییرات ناگهانی و کوتاه‌مدت در محاسبه ی متوسط امتیاز تأثیر زیادی نخواهد داشت. نکته ی کلیدی در این روش کاهش تاثیر امتیازات با گذر زمان است. این راهکار را می توان با استفاده از decay function پیاده سازی کرد که در آن وزن هر امتیاز به صورت e^−λt تعریف می شود. t زمان گذشته از ثبت امتیاز است و λ مقدار ثابتی است (ثابت زوال) که سرعت کاهش تاثیر امتیازات را کنترل می کند. هر چه مقدار آن بیشتر باشد امتیاز قبلی با سرعت بالاتری ورن یا تاثیر خود را ار دست می دهد.
 
این روش به تغییرات طبیعی در دیدگاه کاربران اجازه تأثیرگذاری می‌دهد اما تا حد زیادی از تاثیر امواج ناگهانی و تعمدی جلوگیری می کند. هرچند باید به چالش هایی نظیر تنظیم مقدار ثابت زوال اشاره کرد.

برای پیاده سازی این روش زمان ثبت هر امتیاز در مدل Rating نگهداری می شود. با ثبت یک امتیاز جدید برای یک مقاله، روال زیر برای تمام امتیازات آن مقاله اجرا می شود:

محاسبه ی زمان گذشته از ثبت شدن امتیاز  و نگهداری در فیلد time_difference

محاسبه ی وزن برای امتیاز به صورت math.exp(-time_difference * time_decay_constant)

ضرب امتیاز در وزن محاسبه شده و جمع با امتیاز کلی به صورت total_weight_score += rating.score * weight

جمع وزن محاسبه شده با مجموع وزن ها به صورت  total_weight += weight

در نهایت میانگین به صورت مقابل محاسبه و ذخیره می شود self.average_rating = total_weight_score / total_weight

</div>